{"version":3,"sources":["componentary.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"componentary.js","sourcesContent":["/*global MutationObserver, CSSRule */\n\n/**\n * @fileOverview This file contains the _componentary_ module for\n * emulating Web Components behavior.\n * @name componentary.js<src>\n * @author Etienne Prud’homme\n * @version 1.0.0\n * @link https://github.com/notetiene/componentary\n * @todo Keep track of instances. This way, the style tag could be\n * removed.\n * @license MIT\n */\n\n/**\n * Module to construct custom components (i.e. Element tree). It tries\n * to emulate the behavior of Web Components while being native HTML.\n * @returns {Object} Methods to register a component\n * ({@link registerElement}) and to create an instance of that\n * component ({@link createElement}).\n * @throws {Error} Errors about component initialization.\n */\nvar components = (function() {\n    if (!String.prototype.trim) {\n        String.prototype.trim = function () {\n            return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n        };\n    }\n\n    function mergeObjects(that, object) {\n        var prop;\n        for(prop in object) {\n            if(object.hasOwnProperty(prop) && that[prop] === undefined) {\n                that[prop] = object[prop];\n            }\n        }\n    }\n\n    /**\n     * Utility function to parse CSS from a {@link String}.\n     * @param {String} styleContent - CSS rules as {@link String}.\n     * @returns {CSSRuleList} A list of {@link CSSRule}.\n     * @see http://stackoverflow.com/a/14865690\n     */\n    function rulesForCssText(styleContent) {\n        var doc = document.implementation.createHTMLDocument('');\n        var styleElement = document.createElement('style');\n\n        styleElement.textContent = styleContent.replace(/\\$self/g, '.componentary-lib-self-component');\n        // the style will only be parsed once it is added to a document\n        doc.body.appendChild(styleElement);\n        return styleElement.sheet.cssRules;\n    }\n\n    /**\n     * Transform a {@link CSSRuleList} to String while optionally adding\n     * a prefix before selectors. Currently only support\n     * {@link CSSRuleList} with {@link CSSStyleRule} or\n     * {@link CSSMediaRule}.\n     * @param {CSSRuleList} ruleList - The list to transform.\n     * @param {String} [prefix] - A prefix to add before selectors.\n     * @returns {String} The {@link CSSRulesList} transformed into\n     * {@link String}.\n     * @throws {Error} A rule in {@link ruleList} contains a type not\n     * supported.\n     */\n    function CSSRuleListToString(ruleList, prefix) {\n        var i = 0;\n        var rule = null;\n        var len;\n        var result = '';\n        var _prefix;\n        if(prefix && prefix !== '') {\n            _prefix = prefix + ' ';\n        } else {\n            _prefix = '';\n        }\n\n        for(len = ruleList.length; i < len; i++) {\n            rule = ruleList[i];\n\n            if(rule.type === CSSRule.MEDIA_RULE) {\n                result += ' @media ' + rule.media.mediaText + ' { ';\n                result += CSSRuleListToString(rule.cssRules, prefix);\n                result += ' }';\n                continue;\n            }\n\n            if(rule.type !== CSSRule.STYLE_RULE) {\n                throw new Error('Only style rules and media rules are ' +\n                                'currently supported for style scoping');\n            }\n\n            if(rule.selectorText.trim() === '.componentary-lib-self-component') {\n                result += rule.cssText.replace(/\\.componentary-lib-self-component/g, prefix);\n                continue;\n            }\n\n            result += _prefix + rule.cssText;\n        }\n\n        return result;\n    }\n\n    /**\n     * Utility to add a selector according to {@link topNode} id or\n     * classes. Thus, it “makes” the {@link styleContent} scoped.\n     * @param {String} styleContent - CSS rules to restrict the\n     * scope to {@link topNode}.\n     * @param {Node} topNode - A node that has classes that will act as\n     * scope.\n     */\n    function CSSRulesScoped(styleContent, topNode) {\n        var rules = rulesForCssText(styleContent);\n        var selector = topNode.className;\n        var scopedRules = '';\n\n        if(selector.length < 10) {\n            throw new Error('“topNode” doesn’t contain classes to act as' +\n                            'selector or is too short & risk to have ' +\n                            'collisions');\n        }\n\n        // Replace spaces with the class selector\n        selector = '.' + selector.replace(/ /g, '.');\n\n        scopedRules = CSSRuleListToString(rules, selector);\n\n        return scopedRules;\n    }\n\n\n    /**\n     * Inject the {@link customElement} styles if they’re not present\n     * already.\n     * @param {String} name - The name of the {@link customElement}.\n     * @param {String} style - Scoped CSS for the {@link customElement}.\n     * @param {DocumentFragment} fragment - Fragment representing the\n     * current {@link customElement}.\n     * @param {HTMLElement} topNode - The for {@link customElement}.\n     * @param {String} topNode - Scoped CSS for instances of\n     * {@link customElement}.\n     * @returns {HTMLElement} The new {@link topNode} (if any).\n     */\n    function injectElementStyle(name, style, fragment, topNode, instanceStyle) {\n        var styleID = name + '-componentary-lib-style';\n        var styleInjected = document.getElementById(styleID);\n        var _style = style || null;\n        var styleEl = null;\n        var scopedEl = null;\n        var className = name + '-componentary-lib-scoped';\n\n        if(styleInjected !== null ||\n           Object.prototype.toString.apply(_style) !== '[object String]') {\n            return topNode;\n        }\n\n        styleEl = document.createElement('style');\n        styleEl.id = styleID;\n\n        // Dirty trick to make the CSS scope. Will probably break many\n        // things.\n        scopedEl = document.createElement('div');\n        scopedEl.className = className;\n\n        if(topNode.style) {\n            scopedEl.style.display = topNode.style.display;\n        }\n        scopedEl.appendChild(topNode);\n\n        topNode = scopedEl;\n        fragment.appendChild(scopedEl);\n        styleEl.textContent = CSSRulesScoped(style, scopedEl);\n        if(instanceStyle && instanceStyle !== '') {\n            styleEl.textContent += CSSRulesScoped(instanceStyle, scopedEl);\n        }\n\n        document.head.appendChild(styleEl);\n        return topNode;\n    }\n\n    var customElements = {};\n\n    /**\n     * Compatibility fix.\n     * @see http://stackoverflow.com/a/34292615\n     */\n    var range = document.createRange();\n    range.selectNode(document.body);\n\n    /**\n     * Register a custom element.\n     * @param {String} _name - The name to identify the custom\n     * element.\n     * @param {String} _template - The HTML template.\n     * @param {Object} _proto - Callbacks for WebComponents.\n     * @throws {Error} Various errors about a component\n     * initialization.\n     * @see http://thejackalofjavascript.com/web-components-future-web/#custELeLifeCyncle\n     */\n    var registerElement = function(_name, _template, _proto) {\n        if(_name.constructor !== String || _name === '') {\n            throw new Error('Cannot register the component. The name must be a String.');\n        }\n        if(_template.constructor !== String || _template === '') {\n            throw new Error('Cannot register ' + _name +' component. The template must be a String.');\n        }\n        if(customElements[_name] !== undefined && customElements.hasOwnProperty(_name)) {\n            throw new Error(_name + ' is an already registered component.');\n        }\n\n        var proto = _proto || {};\n\n        Object.defineProperty(customElements, _name, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: {\n                template: _template,\n                proto: proto\n            }\n        });\n\n    };\n\n    /**\n     * Create an instance of a specified element by returning a\n     * {@link DocumentFragment}. The responsability to inject the\n     * fragment is left to the user. This element must be present in\n     * {@link customElements}.\n     * @param {String} _name - The unique name of the element.\n     * @param {String} _style - Optional style that will be added to\n     * the scoped. Note that once an element is created with that\n     * attribute, it is no longer possible to add more style with\n     * {@link createElement}.\n     * @returns {DocumentFragment} - A document fragment containing\n     * the element template and its attached callbacks.\n     * @throws {Error} Component instantiation error.\n     */\n    var createElement = function(_name, _style) {\n        if(!customElements.hasOwnProperty(_name)) {\n            throw new Error('“' + _name + '” is not a registered component');\n        }\n\n        var customElement = customElements[_name];\n        var customStyle = _style || '';\n        var style = customElement.proto.style || undefined;\n\n        // For compatibility reasons, it is the best way to write a String to an\n        // Element.\n        var fragment = range.createContextualFragment(customElement.template);\n\n        var topNode = null;\n\n        // Take the first Node (not a comment)\n        for(var i=0, len=fragment.childNodes.length; i<len; i++) {\n            if(fragment.childNodes[i].nodeType === Node.ELEMENT_NODE ||\n               fragment.childNodes[i].nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                topNode = fragment.childNodes[i];\n                break;\n            }\n        }\n        // Verifies that there’s at least one node\n        if(topNode === null) {\n            throw new Error('The “' + _name + '” component doesn’t contain a valid node.');\n        }\n\n        topNode = injectElementStyle(_name, style, fragment, topNode, customStyle);\n\n        // Note: using proto.createdCallback is useless here (as far\n        // as I know) since it’s handled by the user.\n        // Note: not useless at all if we want to hide some operations.\n        var createdCallback = customElement.proto.createdCallback || {};\n\n        if(createdCallback instanceof Function) {\n            createdCallback.call(topNode);\n        }\n\n        // proto.attachedCallback\n        // This callback is called when the element is attached to the\n        // DOM (i.e. appendChild). It does so because when a\n        // DocumentFragment is attached to the DOM, its content is\n        // emptied (thus removing its childNodes).\n        var attachedCb = customElement.proto.attachedCallback;\n        if(attachedCb instanceof Function) {\n            var observerAttached = new MutationObserver(function(mutations) {\n                for(var i=0, len=mutations.length; i<len; i++) {\n                    // When a DocumentFragment is appended, it becomes\n                    // void\n                    if(mutations[i].type === 'childList' && mutations[i].removedNodes[0] === topNode) {\n                        // XXX: Is it doing anything?\n                        mergeObjects(topNode, fragment);\n                        attachedCb.call(topNode);\n                    }\n                }\n            });\n            observerAttached.observe(fragment, {childList: true});\n        }\n\n        // proto.attributeChangedCallback\n        // This callback is called when an attribute of the container\n        // (top most) element changed. It doesn’t include children\n        // elements.\n        var attributeChangedCb = customElement.proto.attributeChangedCallback;\n        if(attributeChangedCb instanceof Function) {\n            var observerAttr = new MutationObserver(function(mutations) {\n                for(var i = 0, len=mutations.length; i<len; i++) {\n                    if(mutations[i].type === 'attributes') {\n                        attributeChangedCb.call(topNode);\n                    }\n                }\n            });\n\n            // Only observe attribute mutations\n            observerAttr.observe(topNode, {attributes: true});\n        }\n\n        // proto.detachedCallback isn’t implemented\n\n        return topNode;\n    };\n\n    return {\n        registerElement: registerElement,\n        createElement: createElement\n    };\n})();\n\n// componentary.js<src> ends here\n"]}