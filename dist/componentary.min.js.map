{"version":3,"sources":["componentary.js"],"names":["components","mergeObjects","that","object","prop","hasOwnProperty","undefined","rulesForCssText","styleContent","doc","document","implementation","createHTMLDocument","styleElement","createElement","textContent","replace","body","appendChild","sheet","cssRules","CSSRuleListToString","ruleList","prefix","len","_prefix","i","rule","result","length","type","CSSRule","MEDIA_RULE","STYLE_RULE","Error","selectorText","trim","cssText","media","mediaText","CSSRulesScoped","topNode","rules","selector","className","scopedRules","injectElementStyle","name","style","fragment","instanceStyle","styleID","styleInjected","getElementById","_style","styleEl","scopedEl","Object","prototype","toString","apply","id","display","head","String","this","customElements","range","createRange","selectNode","registerElement","_name","_template","_proto","constructor","proto","defineProperty","enumerable","configurable","writable","value","template","customElement","customStyle","createContextualFragment","childNodes","nodeType","Node","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","createdCallback","Function","call","attachedCb","attachedCallback","observerAttached","MutationObserver","mutations","removedNodes","observe","childList","attributeChangedCb","attributeChangedCallback","observerAttr","attributes"],"mappings":"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","file":"componentary.min.js","sourcesContent":["/*global MutationObserver, CSSRule */\n\n/**\n * @fileOverview This file contains the _componentary_ module for\n * emulating Web Components behavior.\n * @name componentary.js<src>\n * @author Etienne Prud’homme\n * @version 1.0.0\n * @link https://github.com/notetiene/componentary\n * @todo Keep track of instances. This way, the style tag could be\n * removed.\n * @license MIT\n */\n\n/**\n * Module to construct custom components (i.e. Element tree). It tries\n * to emulate the behavior of Web Components while being native HTML.\n * @returns {Object} Methods to register a component\n * ({@link registerElement}) and to create an instance of that\n * component ({@link createElement}).\n * @throws {Error} Errors about component initialization.\n */\nvar components = (function() {\n    if (!String.prototype.trim) {\n        String.prototype.trim = function () {\n            return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n        };\n    }\n\n    function mergeObjects(that, object) {\n        var prop;\n        for(prop in object) {\n            if(object.hasOwnProperty(prop) && that[prop] === undefined) {\n                that[prop] = object[prop];\n            }\n        }\n    }\n\n    /**\n     * Utility function to parse CSS from a {@link String}.\n     * @param {String} styleContent - CSS rules as {@link String}.\n     * @returns {CSSRuleList} A list of {@link CSSRule}.\n     * @see http://stackoverflow.com/a/14865690\n     */\n    function rulesForCssText(styleContent) {\n        var doc = document.implementation.createHTMLDocument('');\n        var styleElement = document.createElement('style');\n\n        styleElement.textContent = styleContent.replace(/\\$self/g, '.componentary-lib-self-component');\n        // the style will only be parsed once it is added to a document\n        doc.body.appendChild(styleElement);\n        return styleElement.sheet.cssRules;\n    }\n\n    /**\n     * Transform a {@link CSSRuleList} to String while optionally adding\n     * a prefix before selectors. Currently only support\n     * {@link CSSRuleList} with {@link CSSStyleRule} or\n     * {@link CSSMediaRule}.\n     * @param {CSSRuleList} ruleList - The list to transform.\n     * @param {String} [prefix] - A prefix to add before selectors.\n     * @returns {String} The {@link CSSRulesList} transformed into\n     * {@link String}.\n     * @throws {Error} A rule in {@link ruleList} contains a type not\n     * supported.\n     */\n    function CSSRuleListToString(ruleList, prefix) {\n        var i = 0;\n        var rule = null;\n        var len;\n        var result = '';\n        var _prefix;\n        if(prefix && prefix !== '') {\n            _prefix = prefix + ' ';\n        } else {\n            _prefix = '';\n        }\n\n        for(len = ruleList.length; i < len; i++) {\n            rule = ruleList[i];\n\n            if(rule.type === CSSRule.MEDIA_RULE) {\n                result += ' @media ' + rule.media.mediaText + ' { ';\n                result += CSSRuleListToString(rule.cssRules, prefix);\n                result += ' }';\n                continue;\n            }\n\n            if(rule.type !== CSSRule.STYLE_RULE) {\n                throw new Error('Only style rules and media rules are ' +\n                                'currently supported for style scoping');\n            }\n\n            if(rule.selectorText.trim() === '.componentary-lib-self-component') {\n                result += rule.cssText.replace(/\\.componentary-lib-self-component/g, prefix);\n                continue;\n            }\n\n            result += _prefix + rule.cssText;\n        }\n\n        return result;\n    }\n\n    /**\n     * Utility to add a selector according to {@link topNode} id or\n     * classes. Thus, it “makes” the {@link styleContent} scoped.\n     * @param {String} styleContent - CSS rules to restrict the\n     * scope to {@link topNode}.\n     * @param {Node} topNode - A node that has classes that will act as\n     * scope.\n     */\n    function CSSRulesScoped(styleContent, topNode) {\n        var rules = rulesForCssText(styleContent);\n        var selector = topNode.className;\n        var scopedRules = '';\n\n        if(selector.length < 10) {\n            throw new Error('“topNode” doesn’t contain classes to act as' +\n                            'selector or is too short & risk to have ' +\n                            'collisions');\n        }\n\n        // Replace spaces with the class selector\n        selector = '.' + selector.replace(/ /g, '.');\n\n        scopedRules = CSSRuleListToString(rules, selector);\n\n        return scopedRules;\n    }\n\n\n    /**\n     * Inject the {@link customElement} styles if they’re not present\n     * already.\n     * @param {String} name - The name of the {@link customElement}.\n     * @param {String} style - Scoped CSS for the {@link customElement}.\n     * @param {DocumentFragment} fragment - Fragment representing the\n     * current {@link customElement}.\n     * @param {HTMLElement} topNode - The for {@link customElement}.\n     * @param {String} topNode - Scoped CSS for instances of\n     * {@link customElement}.\n     * @returns {HTMLElement} The new {@link topNode} (if any).\n     */\n    function injectElementStyle(name, style, fragment, topNode, instanceStyle) {\n        var styleID = name + '-componentary-lib-style';\n        var styleInjected = document.getElementById(styleID);\n        var _style = style || null;\n        var styleEl = null;\n        var scopedEl = null;\n        var className = name + '-componentary-lib-scoped';\n\n        if(styleInjected !== null ||\n           Object.prototype.toString.apply(_style) !== '[object String]') {\n            return topNode;\n        }\n\n        styleEl = document.createElement('style');\n        styleEl.id = styleID;\n\n        // Dirty trick to make the CSS scope. Will probably break many\n        // things.\n        scopedEl = document.createElement('div');\n        scopedEl.className = className;\n\n        if(topNode.style) {\n            scopedEl.style.display = topNode.style.display;\n        }\n        scopedEl.appendChild(topNode);\n\n        topNode = scopedEl;\n        fragment.appendChild(scopedEl);\n        styleEl.textContent = CSSRulesScoped(style, scopedEl);\n        if(instanceStyle && instanceStyle !== '') {\n            styleEl.textContent += CSSRulesScoped(instanceStyle, scopedEl);\n        }\n\n        document.head.appendChild(styleEl);\n        return topNode;\n    }\n\n    var customElements = {};\n\n    /**\n     * Compatibility fix.\n     * @see http://stackoverflow.com/a/34292615\n     */\n    var range = document.createRange();\n    range.selectNode(document.body);\n\n    /**\n     * Register a custom element.\n     * @param {String} _name - The name to identify the custom\n     * element.\n     * @param {String} _template - The HTML template.\n     * @param {Object} _proto - Callbacks for WebComponents.\n     * @throws {Error} Various errors about a component\n     * initialization.\n     * @see http://thejackalofjavascript.com/web-components-future-web/#custELeLifeCyncle\n     */\n    var registerElement = function(_name, _template, _proto) {\n        if(_name.constructor !== String || _name === '') {\n            throw new Error('Cannot register the component. The name must be a String.');\n        }\n        if(_template.constructor !== String || _template === '') {\n            throw new Error('Cannot register ' + _name +' component. The template must be a String.');\n        }\n        if(customElements[_name] !== undefined && customElements.hasOwnProperty(_name)) {\n            throw new Error(_name + ' is an already registered component.');\n        }\n\n        var proto = _proto || {};\n\n        Object.defineProperty(customElements, _name, {\n            enumerable: false,\n            configurable: false,\n            writable: false,\n            value: {\n                template: _template,\n                proto: proto\n            }\n        });\n\n    };\n\n    /**\n     * Create an instance of a specified element by returning a\n     * {@link DocumentFragment}. The responsability to inject the\n     * fragment is left to the user. This element must be present in\n     * {@link customElements}.\n     * @param {String} _name - The unique name of the element.\n     * @param {String} _style - Optional style that will be added to\n     * the scoped. Note that once an element is created with that\n     * attribute, it is no longer possible to add more style with\n     * {@link createElement}.\n     * @returns {DocumentFragment} - A document fragment containing\n     * the element template and its attached callbacks.\n     * @throws {Error} Component instantiation error.\n     */\n    var createElement = function(_name, _style) {\n        if(!customElements.hasOwnProperty(_name)) {\n            throw new Error('“' + _name + '” is not a registered component');\n        }\n\n        var customElement = customElements[_name];\n        var customStyle = _style || '';\n        var style = customElement.proto.style || undefined;\n\n        // For compatibility reasons, it is the best way to write a String to an\n        // Element.\n        var fragment = range.createContextualFragment(customElement.template);\n\n        var topNode = null;\n\n        // Take the first Node (not a comment)\n        for(var i=0, len=fragment.childNodes.length; i<len; i++) {\n            if(fragment.childNodes[i].nodeType === Node.ELEMENT_NODE ||\n               fragment.childNodes[i].nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                topNode = fragment.childNodes[i];\n                break;\n            }\n        }\n        // Verifies that there’s at least one node\n        if(topNode === null) {\n            throw new Error('The “' + _name + '” component doesn’t contain a valid node.');\n        }\n\n        topNode = injectElementStyle(_name, style, fragment, topNode, customStyle);\n\n        // Note: using proto.createdCallback is useless here (as far\n        // as I know) since it’s handled by the user.\n        // Note: not useless at all if we want to hide some operations.\n        var createdCallback = customElement.proto.createdCallback || {};\n\n        if(createdCallback instanceof Function) {\n            createdCallback.call(topNode);\n        }\n\n        // proto.attachedCallback\n        // This callback is called when the element is attached to the\n        // DOM (i.e. appendChild). It does so because when a\n        // DocumentFragment is attached to the DOM, its content is\n        // emptied (thus removing its childNodes).\n        var attachedCb = customElement.proto.attachedCallback;\n        if(attachedCb instanceof Function) {\n            var observerAttached = new MutationObserver(function(mutations) {\n                for(var i=0, len=mutations.length; i<len; i++) {\n                    // When a DocumentFragment is appended, it becomes\n                    // void\n                    if(mutations[i].type === 'childList' && mutations[i].removedNodes[0] === topNode) {\n                        // XXX: Is it doing anything?\n                        mergeObjects(topNode, fragment);\n                        attachedCb.call(topNode);\n                    }\n                }\n            });\n            observerAttached.observe(fragment, {childList: true});\n        }\n\n        // proto.attributeChangedCallback\n        // This callback is called when an attribute of the container\n        // (top most) element changed. It doesn’t include children\n        // elements.\n        var attributeChangedCb = customElement.proto.attributeChangedCallback;\n        if(attributeChangedCb instanceof Function) {\n            var observerAttr = new MutationObserver(function(mutations) {\n                for(var i = 0, len=mutations.length; i<len; i++) {\n                    if(mutations[i].type === 'attributes') {\n                        attributeChangedCb.call(topNode);\n                    }\n                }\n            });\n\n            // Only observe attribute mutations\n            observerAttr.observe(topNode, {attributes: true});\n        }\n\n        // proto.detachedCallback isn’t implemented\n\n        return topNode;\n    };\n\n    return {\n        registerElement: registerElement,\n        createElement: createElement\n    };\n})();\n\n// componentary.js<src> ends here\n"]}